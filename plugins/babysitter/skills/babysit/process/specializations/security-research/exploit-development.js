/**
 * @process specializations/security-research/exploit-development
 * @description Development of proof-of-concept exploits to demonstrate vulnerability impact and validate
 * severity assessment. Covers various exploitation techniques for memory corruption, web vulnerabilities,
 * and logic flaws following ethical guidelines.
 * @inputs { projectName: string, vulnerability: object, targetEnvironment?: object }
 * @outputs { success: boolean, exploit: object, impactDemonstration: object, artifacts: array }
 *
 * @example
 * const result = await orchestrate('specializations/security-research/exploit-development', {
 *   projectName: 'Buffer Overflow PoC',
 *   vulnerability: {
 *     type: 'stack-buffer-overflow',
 *     location: 'libparser.so',
 *     cweId: 'CWE-121'
 *   },
 *   targetEnvironment: { os: 'linux', arch: 'x64', mitigations: ['aslr', 'nx'] }
 * });
 *
 * @references
 * - Exploit Database: https://www.exploit-db.com/
 * - ROPgadget: https://github.com/JonathanSalwan/ROPgadget
 * - pwntools: https://docs.pwntools.com/
 */

import { defineTask } from '@a5c-ai/babysitter-sdk';

export async function process(inputs, ctx) {
  const {
    projectName,
    vulnerability,
    targetEnvironment = { os: 'linux', arch: 'x64' },
    ethicalScope = 'proof-of-concept',
    outputDir = 'exploit-dev-output'
  } = inputs;

  const startTime = ctx.now();
  const artifacts = [];

  ctx.log('info', `Starting Exploit Development for ${projectName}`);
  ctx.log('info', `Vulnerability: ${vulnerability.type} (${vulnerability.cweId})`);

  // Ethical verification
  await ctx.breakpoint({
    question: `Exploit development for ${vulnerability.type}. Confirm ethical scope is "${ethicalScope}" and proper authorization exists. Proceed?`,
    title: 'Ethical Authorization Check',
    context: {
      runId: ctx.runId,
      vulnerability,
      scope: ethicalScope
    }
  });

  // ============================================================================
  // PHASE 1: VULNERABILITY ANALYSIS
  // ============================================================================

  ctx.log('info', 'Phase 1: Analyzing vulnerability for exploitation');

  const vulnAnalysis = await ctx.task(exploitVulnAnalysisTask, {
    projectName,
    vulnerability,
    targetEnvironment,
    outputDir
  });

  artifacts.push(...vulnAnalysis.artifacts);

  // ============================================================================
  // PHASE 2: MITIGATION ASSESSMENT
  // ============================================================================

  ctx.log('info', 'Phase 2: Assessing security mitigations');

  const mitigationAssessment = await ctx.task(mitigationAssessmentTask, {
    projectName,
    vulnerability,
    targetEnvironment,
    vulnAnalysis,
    outputDir
  });

  artifacts.push(...mitigationAssessment.artifacts);

  // ============================================================================
  // PHASE 3: EXPLOIT STRATEGY
  // ============================================================================

  ctx.log('info', 'Phase 3: Developing exploitation strategy');

  const exploitStrategy = await ctx.task(exploitStrategyTask, {
    projectName,
    vulnerability,
    vulnAnalysis,
    mitigationAssessment,
    outputDir
  });

  artifacts.push(...exploitStrategy.artifacts);

  // ============================================================================
  // PHASE 4: PRIMITIVE DEVELOPMENT
  // ============================================================================

  ctx.log('info', 'Phase 4: Developing exploitation primitives');

  const primitiveDev = await ctx.task(primitiveDevelopmentTask, {
    projectName,
    exploitStrategy,
    targetEnvironment,
    outputDir
  });

  artifacts.push(...primitiveDev.artifacts);

  // ============================================================================
  // PHASE 5: POC IMPLEMENTATION
  // ============================================================================

  ctx.log('info', 'Phase 5: Implementing proof-of-concept');

  const pocImplementation = await ctx.task(pocImplementationTask, {
    projectName,
    exploitStrategy,
    primitiveDev,
    targetEnvironment,
    ethicalScope,
    outputDir
  });

  artifacts.push(...pocImplementation.artifacts);

  // ============================================================================
  // PHASE 6: RELIABILITY TESTING
  // ============================================================================

  ctx.log('info', 'Phase 6: Testing exploit reliability');

  const reliabilityTesting = await ctx.task(reliabilityTestingTask, {
    projectName,
    pocImplementation,
    targetEnvironment,
    outputDir
  });

  artifacts.push(...reliabilityTesting.artifacts);

  // ============================================================================
  // PHASE 7: DOCUMENTATION
  // ============================================================================

  ctx.log('info', 'Phase 7: Documenting exploit for responsible disclosure');

  const documentation = await ctx.task(exploitDocumentationTask, {
    projectName,
    vulnerability,
    exploitStrategy,
    pocImplementation,
    reliabilityTesting,
    outputDir
  });

  artifacts.push(...documentation.artifacts);

  await ctx.breakpoint({
    question: `Exploit development complete. Reliability: ${reliabilityTesting.successRate}%. Impact demonstrated: ${pocImplementation.impact}. Review for responsible disclosure?`,
    title: 'Exploit Development Complete',
    context: {
      runId: ctx.runId,
      summary: {
        vulnerability: vulnerability.type,
        exploitType: exploitStrategy.technique,
        reliability: reliabilityTesting.successRate,
        impact: pocImplementation.impact
      },
      files: documentation.artifacts.map(a => ({ path: a.path, format: a.format || 'markdown', label: a.label }))
    }
  });

  const endTime = ctx.now();

  return {
    success: true,
    projectName,
    exploit: {
      technique: exploitStrategy.technique,
      reliability: reliabilityTesting.successRate,
      pocPath: pocImplementation.pocPath
    },
    impactDemonstration: {
      impact: pocImplementation.impact,
      proof: pocImplementation.proofOfImpact
    },
    artifacts,
    duration: endTime - startTime,
    metadata: {
      processId: 'specializations/security-research/exploit-development',
      timestamp: startTime,
      ethicalScope,
      outputDir
    }
  };
}

// ============================================================================
// TASK DEFINITIONS
// ============================================================================

export const exploitVulnAnalysisTask = defineTask('exploit-vuln-analysis', (args, taskCtx) => ({
  kind: 'agent',
  title: `Analyze for Exploitation - ${args.projectName}`,
  agent: {
    name: 'exploit-developer',
    prompt: {
      role: 'Exploit Research Analyst',
      task: 'Analyze vulnerability for exploitation potential',
      context: args,
      instructions: [
        '1. Understand vulnerability mechanics',
        '2. Identify exploitable primitives',
        '3. Determine control over corruption',
        '4. Map memory layout',
        '5. Identify useful gadgets',
        '6. Assess exploit complexity',
        '7. Identify constraints',
        '8. Document exploitation potential'
      ],
      outputFormat: 'JSON with exploitation analysis'
    },
    outputSchema: {
      type: 'object',
      required: ['exploitable', 'primitives', 'constraints', 'artifacts'],
      properties: {
        exploitable: { type: 'boolean' },
        primitives: { type: 'array' },
        constraints: { type: 'array' },
        memoryLayout: { type: 'object' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'exploit-dev', 'analysis']
}));

export const mitigationAssessmentTask = defineTask('mitigation-assessment', (args, taskCtx) => ({
  kind: 'agent',
  title: `Assess Mitigations - ${args.projectName}`,
  agent: {
    name: 'exploit-developer',
    prompt: {
      role: 'Mitigation Assessment Specialist',
      task: 'Assess security mitigations',
      context: args,
      instructions: [
        '1. Check ASLR implementation',
        '2. Check NX/DEP status',
        '3. Check stack canaries',
        '4. Check RELRO status',
        '5. Check CFI implementation',
        '6. Identify bypass techniques',
        '7. Assess mitigation strength',
        '8. Document mitigation status'
      ],
      outputFormat: 'JSON with mitigation assessment'
    },
    outputSchema: {
      type: 'object',
      required: ['mitigations', 'bypassPossible', 'artifacts'],
      properties: {
        mitigations: { type: 'object' },
        bypassPossible: { type: 'array' },
        difficulty: { type: 'string' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'exploit-dev', 'mitigations']
}));

export const exploitStrategyTask = defineTask('exploit-strategy', (args, taskCtx) => ({
  kind: 'agent',
  title: `Develop Strategy - ${args.projectName}`,
  agent: {
    name: 'exploit-developer',
    prompt: {
      role: 'Exploitation Strategist',
      task: 'Develop exploitation strategy',
      context: args,
      instructions: [
        '1. Choose exploitation technique',
        '2. Design exploit chain',
        '3. Plan mitigation bypasses',
        '4. Identify required gadgets',
        '5. Design payload delivery',
        '6. Plan for reliability',
        '7. Consider target constraints',
        '8. Document strategy'
      ],
      outputFormat: 'JSON with exploit strategy'
    },
    outputSchema: {
      type: 'object',
      required: ['technique', 'exploitChain', 'artifacts'],
      properties: {
        technique: { type: 'string' },
        exploitChain: { type: 'array' },
        requiredGadgets: { type: 'array' },
        payloadType: { type: 'string' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'exploit-dev', 'strategy']
}));

export const primitiveDevelopmentTask = defineTask('primitive-development', (args, taskCtx) => ({
  kind: 'agent',
  title: `Develop Primitives - ${args.projectName}`,
  agent: {
    name: 'exploit-developer',
    prompt: {
      role: 'Exploit Primitive Developer',
      task: 'Develop exploitation primitives',
      context: args,
      instructions: [
        '1. Develop memory read primitive',
        '2. Develop memory write primitive',
        '3. Develop control flow primitive',
        '4. Build ROP/JOP chains',
        '5. Develop info leak primitive',
        '6. Test primitives independently',
        '7. Chain primitives together',
        '8. Document primitives'
      ],
      outputFormat: 'JSON with primitives'
    },
    outputSchema: {
      type: 'object',
      required: ['primitives', 'working', 'artifacts'],
      properties: {
        primitives: { type: 'array' },
        working: { type: 'boolean' },
        ropChain: { type: 'array' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'exploit-dev', 'primitives']
}));

export const pocImplementationTask = defineTask('poc-implementation', (args, taskCtx) => ({
  kind: 'agent',
  title: `Implement PoC - ${args.projectName}`,
  agent: {
    name: 'exploit-developer',
    prompt: {
      role: 'PoC Developer',
      task: 'Implement proof-of-concept exploit',
      context: args,
      instructions: [
        '1. Implement exploit code',
        '2. Integrate primitives',
        '3. Add payload (benign for PoC)',
        '4. Handle edge cases',
        '5. Demonstrate impact safely',
        '6. Create reproducible PoC',
        '7. Test on target environment',
        '8. Document PoC usage'
      ],
      outputFormat: 'JSON with PoC implementation'
    },
    outputSchema: {
      type: 'object',
      required: ['pocPath', 'impact', 'working', 'artifacts'],
      properties: {
        pocPath: { type: 'string' },
        impact: { type: 'string' },
        working: { type: 'boolean' },
        proofOfImpact: { type: 'string' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'exploit-dev', 'poc']
}));

export const reliabilityTestingTask = defineTask('reliability-testing', (args, taskCtx) => ({
  kind: 'agent',
  title: `Test Reliability - ${args.projectName}`,
  agent: {
    name: 'exploit-developer',
    prompt: {
      role: 'Exploit Reliability Tester',
      task: 'Test exploit reliability',
      context: args,
      instructions: [
        '1. Run exploit multiple times',
        '2. Test on different configurations',
        '3. Measure success rate',
        '4. Identify failure modes',
        '5. Test with ASLR enabled',
        '6. Test stability',
        '7. Document reliability metrics',
        '8. Suggest improvements'
      ],
      outputFormat: 'JSON with reliability testing'
    },
    outputSchema: {
      type: 'object',
      required: ['successRate', 'testedCount', 'artifacts'],
      properties: {
        successRate: { type: 'number' },
        testedCount: { type: 'number' },
        failureModes: { type: 'array' },
        configurations: { type: 'array' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'exploit-dev', 'reliability']
}));

export const exploitDocumentationTask = defineTask('exploit-documentation', (args, taskCtx) => ({
  kind: 'agent',
  title: `Document Exploit - ${args.projectName}`,
  agent: {
    name: 'security-report-writer',
    prompt: {
      role: 'Exploit Documentation Specialist',
      task: 'Document exploit for responsible disclosure',
      context: args,
      instructions: [
        '1. Document vulnerability details',
        '2. Document exploitation technique',
        '3. Provide impact assessment',
        '4. Include PoC instructions',
        '5. Document reliability',
        '6. Provide remediation guidance',
        '7. Follow responsible disclosure',
        '8. Format professionally'
      ],
      outputFormat: 'JSON with documentation'
    },
    outputSchema: {
      type: 'object',
      required: ['reportPath', 'summary', 'artifacts'],
      properties: {
        reportPath: { type: 'string' },
        summary: { type: 'object' },
        disclosureReady: { type: 'boolean' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'exploit-dev', 'documentation']
}));
