/**
 * @process specializations/cryptography-blockchain/incident-response-exploits
 * @description Incident Response for Exploits - Structured incident response process for smart contract exploits
 * including detection, containment, recovery, and post-mortem analysis.
 * @inputs { projectName: string, incidentType: string, severity: string, affectedContracts?: array }
 * @outputs { success: boolean, incidentReport: object, recoveryPlan: object, artifacts: array }
 *
 * @example
 * const result = await orchestrate('specializations/cryptography-blockchain/incident-response-exploits', {
 *   projectName: 'Protocol Exploit Response',
 *   incidentType: 'reentrancy-attack',
 *   severity: 'critical',
 *   affectedContracts: ['Vault', 'Strategy']
 * });
 *
 * @references
 * - REKT News: https://rekt.news/
 * - DeFi Security Best Practices: https://github.com/crytic/building-secure-contracts
 */

import { defineTask } from '@a5c-ai/babysitter-sdk';

export async function process(inputs, ctx) {
  const {
    projectName,
    incidentType,
    severity,
    affectedContracts = [],
    estimatedLoss = 0,
    features = ['pause-contracts', 'war-room', 'communications'],
    outputDir = 'incident-output'
  } = inputs;

  const startTime = ctx.now();
  const artifacts = [];

  ctx.log('info', `Starting Incident Response: ${projectName}`);

  const incidentDetection = await ctx.task(incidentDetectionTask, { projectName, incidentType, severity, outputDir });
  artifacts.push(...incidentDetection.artifacts);

  const initialAssessment = await ctx.task(initialAssessmentTask, { projectName, affectedContracts, estimatedLoss, outputDir });
  artifacts.push(...initialAssessment.artifacts);

  const containmentActions = await ctx.task(containmentActionsTask, { projectName, features, outputDir });
  artifacts.push(...containmentActions.artifacts);

  const rootCauseAnalysis = await ctx.task(rootCauseAnalysisTask, { projectName, incidentType, outputDir });
  artifacts.push(...rootCauseAnalysis.artifacts);

  const recoveryPlan = await ctx.task(recoveryPlanTask, { projectName, outputDir });
  artifacts.push(...recoveryPlan.artifacts);

  const communicationPlan = await ctx.task(communicationPlanTask, { projectName, features, outputDir });
  artifacts.push(...communicationPlan.artifacts);

  const remediationImplementation = await ctx.task(remediationImplementationTask, { projectName, outputDir });
  artifacts.push(...remediationImplementation.artifacts);

  const postMortemReport = await ctx.task(postMortemReportTask, { projectName, outputDir });
  artifacts.push(...postMortemReport.artifacts);

  const endTime = ctx.now();

  return {
    success: true,
    projectName,
    incidentReport: { type: incidentType, severity, affectedContracts, estimatedLoss },
    recoveryPlan: recoveryPlan.plan,
    postMortem: postMortemReport,
    artifacts,
    duration: endTime - startTime,
    metadata: { processId: 'specializations/cryptography-blockchain/incident-response-exploits', timestamp: startTime }
  };
}

export const incidentDetectionTask = defineTask('incident-detection', (args, taskCtx) => ({
  kind: 'agent',
  title: `Incident Detection - ${args.projectName}`,
  agent: {
    name: 'detection-engineer',
    prompt: {
      role: 'Incident Detection Engineer',
      task: 'Document incident detection',
      context: args,
      instructions: ['1. Record detection time', '2. Document detection method', '3. Identify alerting source', '4. Record initial observations', '5. Capture transaction data', '6. Document block numbers', '7. Identify attacker addresses', '8. Record on-chain evidence', '9. Create timeline', '10. Classify incident'],
      outputFormat: 'JSON with incident detection'
    },
    outputSchema: { type: 'object', required: ['detection', 'timeline', 'artifacts'], properties: { detection: { type: 'object' }, timeline: { type: 'array' }, evidence: { type: 'object' }, artifacts: { type: 'array' } } }
  },
  io: { inputJsonPath: `tasks/${taskCtx.effectId}/input.json`, outputJsonPath: `tasks/${taskCtx.effectId}/result.json` },
  labels: ['incident', 'detection']
}));

export const initialAssessmentTask = defineTask('initial-assessment', (args, taskCtx) => ({
  kind: 'agent',
  title: `Initial Assessment - ${args.projectName}`,
  agent: {
    name: 'assessment-engineer',
    prompt: {
      role: 'Initial Assessment Engineer',
      task: 'Assess incident impact',
      context: args,
      instructions: ['1. Assess fund loss', '2. Identify affected users', '3. Determine scope', '4. Assess ongoing risk', '5. Identify attack vector', '6. Check related contracts', '7. Assess protocol health', '8. Identify dependencies', '9. Document assessment', '10. Prioritize actions'],
      outputFormat: 'JSON with initial assessment'
    },
    outputSchema: { type: 'object', required: ['assessment', 'impact', 'artifacts'], properties: { assessment: { type: 'object' }, impact: { type: 'object' }, affectedUsers: { type: 'number' }, artifacts: { type: 'array' } } }
  },
  io: { inputJsonPath: `tasks/${taskCtx.effectId}/input.json`, outputJsonPath: `tasks/${taskCtx.effectId}/result.json` },
  labels: ['incident', 'assessment']
}));

export const containmentActionsTask = defineTask('containment-actions', (args, taskCtx) => ({
  kind: 'agent',
  title: `Containment Actions - ${args.projectName}`,
  agent: {
    name: 'containment-engineer',
    prompt: {
      role: 'Containment Engineer',
      task: 'Execute containment actions',
      context: args,
      instructions: ['1. Pause affected contracts', '2. Revoke permissions', '3. Blacklist attacker', '4. Freeze remaining funds', '5. Disable frontend', '6. Alert exchanges', '7. Monitor for copycats', '8. Secure admin keys', '9. Document actions', '10. Verify containment'],
      outputFormat: 'JSON with containment actions'
    },
    outputSchema: { type: 'object', required: ['actions', 'status', 'artifacts'], properties: { actions: { type: 'array' }, status: { type: 'object' }, remainingRisk: { type: 'object' }, artifacts: { type: 'array' } } }
  },
  io: { inputJsonPath: `tasks/${taskCtx.effectId}/input.json`, outputJsonPath: `tasks/${taskCtx.effectId}/result.json` },
  labels: ['incident', 'containment']
}));

export const rootCauseAnalysisTask = defineTask('root-cause-analysis', (args, taskCtx) => ({
  kind: 'agent',
  title: `Root Cause Analysis - ${args.projectName}`,
  agent: {
    name: 'rca-engineer',
    prompt: {
      role: 'Root Cause Analysis Engineer',
      task: 'Analyze root cause',
      context: args,
      instructions: ['1. Analyze attack transactions', '2. Reverse engineer exploit', '3. Identify vulnerability', '4. Trace attack flow', '5. Understand prerequisites', '6. Identify code issues', '7. Check for variations', '8. Assess preventability', '9. Document root cause', '10. Create attack diagram'],
      outputFormat: 'JSON with root cause analysis'
    },
    outputSchema: { type: 'object', required: ['rootCause', 'vulnerability', 'artifacts'], properties: { rootCause: { type: 'object' }, vulnerability: { type: 'object' }, attackFlow: { type: 'array' }, artifacts: { type: 'array' } } }
  },
  io: { inputJsonPath: `tasks/${taskCtx.effectId}/input.json`, outputJsonPath: `tasks/${taskCtx.effectId}/result.json` },
  labels: ['incident', 'rca']
}));

export const recoveryPlanTask = defineTask('recovery-plan', (args, taskCtx) => ({
  kind: 'agent',
  title: `Recovery Plan - ${args.projectName}`,
  agent: {
    name: 'recovery-engineer',
    prompt: {
      role: 'Recovery Plan Engineer',
      task: 'Create recovery plan',
      context: args,
      instructions: ['1. Plan fund recovery', '2. Design compensation', '3. Plan contract upgrade', '4. Define testing requirements', '5. Plan staged recovery', '6. Define rollback criteria', '7. Plan user migration', '8. Define success metrics', '9. Create timeline', '10. Document plan'],
      outputFormat: 'JSON with recovery plan'
    },
    outputSchema: { type: 'object', required: ['plan', 'timeline', 'artifacts'], properties: { plan: { type: 'object' }, timeline: { type: 'array' }, compensation: { type: 'object' }, artifacts: { type: 'array' } } }
  },
  io: { inputJsonPath: `tasks/${taskCtx.effectId}/input.json`, outputJsonPath: `tasks/${taskCtx.effectId}/result.json` },
  labels: ['incident', 'recovery']
}));

export const communicationPlanTask = defineTask('communication-plan', (args, taskCtx) => ({
  kind: 'agent',
  title: `Communication Plan - ${args.projectName}`,
  agent: {
    name: 'comms-engineer',
    prompt: {
      role: 'Communication Engineer',
      task: 'Execute communication plan',
      context: args,
      instructions: ['1. Draft initial disclosure', '2. Prepare user communication', '3. Draft exchange notices', '4. Prepare press statement', '5. Plan social updates', '6. Prepare investor comms', '7. Draft regulatory notices', '8. Plan ongoing updates', '9. Prepare FAQ', '10. Document all comms'],
      outputFormat: 'JSON with communication plan'
    },
    outputSchema: { type: 'object', required: ['communications', 'timeline', 'artifacts'], properties: { communications: { type: 'array' }, timeline: { type: 'array' }, templates: { type: 'object' }, artifacts: { type: 'array' } } }
  },
  io: { inputJsonPath: `tasks/${taskCtx.effectId}/input.json`, outputJsonPath: `tasks/${taskCtx.effectId}/result.json` },
  labels: ['incident', 'communications']
}));

export const remediationImplementationTask = defineTask('remediation-implementation', (args, taskCtx) => ({
  kind: 'agent',
  title: `Remediation Implementation - ${args.projectName}`,
  agent: {
    name: 'remediation-engineer',
    prompt: {
      role: 'Remediation Engineer',
      task: 'Implement fixes',
      context: args,
      instructions: ['1. Develop fix', '2. Review fix thoroughly', '3. Test fix extensively', '4. Get external review', '5. Plan deployment', '6. Deploy fix', '7. Verify fix', '8. Monitor for issues', '9. Resume operations', '10. Document fix'],
      outputFormat: 'JSON with remediation implementation'
    },
    outputSchema: { type: 'object', required: ['fix', 'verification', 'artifacts'], properties: { fix: { type: 'object' }, verification: { type: 'object' }, deployment: { type: 'object' }, artifacts: { type: 'array' } } }
  },
  io: { inputJsonPath: `tasks/${taskCtx.effectId}/input.json`, outputJsonPath: `tasks/${taskCtx.effectId}/result.json` },
  labels: ['incident', 'remediation']
}));

export const postMortemReportTask = defineTask('post-mortem-report', (args, taskCtx) => ({
  kind: 'agent',
  title: `Post-Mortem Report - ${args.projectName}`,
  agent: {
    name: 'postmortem-engineer',
    prompt: {
      role: 'Post-Mortem Engineer',
      task: 'Create post-mortem report',
      context: args,
      instructions: ['1. Summarize incident', '2. Document timeline', '3. Explain root cause', '4. Document response', '5. Analyze what worked', '6. Identify improvements', '7. List action items', '8. Document lessons', '9. Create recommendations', '10. Publish report'],
      outputFormat: 'JSON with post-mortem report'
    },
    outputSchema: { type: 'object', required: ['report', 'lessons', 'artifacts'], properties: { report: { type: 'object' }, lessons: { type: 'array' }, actionItems: { type: 'array' }, artifacts: { type: 'array' } } }
  },
  io: { inputJsonPath: `tasks/${taskCtx.effectId}/input.json`, outputJsonPath: `tasks/${taskCtx.effectId}/result.json` },
  labels: ['incident', 'postmortem']
}));
