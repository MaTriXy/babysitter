/**
 * @process specializations/security-research/vulnerability-research-workflow
 * @description Comprehensive process for systematic vulnerability discovery in target applications or systems.
 * Covers target analysis, reconnaissance, testing methodologies, vulnerability validation, and documentation
 * following industry standards like OWASP Testing Guide and PTES.
 * @inputs { projectName: string, targetScope: object, authorizationType?: string, testingMethodology?: string }
 * @outputs { success: boolean, vulnerabilitiesFound: array, researchReport: object, artifacts: array }
 *
 * @example
 * const result = await orchestrate('specializations/security-research/vulnerability-research-workflow', {
 *   projectName: 'Web Application Security Research',
 *   targetScope: {
 *     applications: ['https://app.target.com'],
 *     apis: ['https://api.target.com'],
 *     codebase: 'https://github.com/target/app'
 *   },
 *   authorizationType: 'bug-bounty',
 *   testingMethodology: 'OWASP'
 * });
 *
 * @references
 * - OWASP Testing Guide: https://owasp.org/www-project-web-security-testing-guide/
 * - PTES: https://www.pentest-standard.org/
 * - CWE Top 25: https://cwe.mitre.org/top25/
 */

import { defineTask } from '@a5c-ai/babysitter-sdk';

export async function process(inputs, ctx) {
  const {
    projectName,
    targetScope = {},
    authorizationType = 'authorized',
    testingMethodology = 'OWASP',
    vulnerabilityClasses = ['injection', 'authentication', 'authorization', 'cryptography', 'logic'],
    outputDir = 'vulnerability-research-output',
    documentationLevel = 'detailed'
  } = inputs;

  const startTime = ctx.now();
  const artifacts = [];
  const vulnerabilitiesFound = [];

  ctx.log('info', `Starting Vulnerability Research Workflow for ${projectName}`);
  ctx.log('info', `Methodology: ${testingMethodology}, Authorization: ${authorizationType}`);

  // ============================================================================
  // PHASE 1: SCOPE DEFINITION AND AUTHORIZATION
  // ============================================================================

  ctx.log('info', 'Phase 1: Defining scope and verifying authorization');

  const scopeDefinition = await ctx.task(scopeDefinitionTask, {
    projectName,
    targetScope,
    authorizationType,
    testingMethodology,
    outputDir
  });

  artifacts.push(...scopeDefinition.artifacts);

  await ctx.breakpoint({
    question: `Scope defined for ${projectName}. ${scopeDefinition.targetsInScope} targets identified. Authorization verified: ${scopeDefinition.authorizationVerified}. Proceed with reconnaissance?`,
    title: 'Scope and Authorization Review',
    context: {
      runId: ctx.runId,
      scope: scopeDefinition,
      files: scopeDefinition.artifacts.map(a => ({ path: a.path, format: a.format || 'json', label: a.label }))
    }
  });

  // ============================================================================
  // PHASE 2: TARGET ANALYSIS AND RECONNAISSANCE
  // ============================================================================

  ctx.log('info', 'Phase 2: Analyzing target architecture and attack surface');

  const targetAnalysis = await ctx.task(targetAnalysisTask, {
    projectName,
    targetScope,
    scopeDefinition,
    outputDir
  });

  artifacts.push(...targetAnalysis.artifacts);

  // ============================================================================
  // PHASE 3: ENTRY POINT ENUMERATION
  // ============================================================================

  ctx.log('info', 'Phase 3: Enumerating entry points and data flows');

  const entryPointEnumeration = await ctx.task(entryPointEnumerationTask, {
    projectName,
    targetAnalysis,
    outputDir
  });

  artifacts.push(...entryPointEnumeration.artifacts);

  // ============================================================================
  // PHASE 4: VULNERABILITY DISCOVERY
  // ============================================================================

  ctx.log('info', 'Phase 4: Applying vulnerability discovery techniques');

  const vulnerabilityDiscovery = await ctx.task(vulnerabilityDiscoveryTask, {
    projectName,
    targetAnalysis,
    entryPointEnumeration,
    vulnerabilityClasses,
    testingMethodology,
    outputDir
  });

  vulnerabilitiesFound.push(...vulnerabilityDiscovery.vulnerabilities);
  artifacts.push(...vulnerabilityDiscovery.artifacts);

  await ctx.breakpoint({
    question: `Vulnerability discovery complete. Found ${vulnerabilityDiscovery.vulnerabilities.length} potential vulnerabilities. Proceed with validation?`,
    title: 'Vulnerability Discovery Review',
    context: {
      runId: ctx.runId,
      discovered: vulnerabilityDiscovery.vulnerabilities.length,
      bySeverity: vulnerabilityDiscovery.bySeverity,
      files: vulnerabilityDiscovery.artifacts.map(a => ({ path: a.path, format: a.format || 'json', label: a.label }))
    }
  });

  // ============================================================================
  // PHASE 5: VULNERABILITY VALIDATION
  // ============================================================================

  ctx.log('info', 'Phase 5: Validating and confirming findings');

  const vulnerabilityValidation = await ctx.task(vulnerabilityValidationTask, {
    projectName,
    vulnerabilities: vulnerabilityDiscovery.vulnerabilities,
    outputDir
  });

  artifacts.push(...vulnerabilityValidation.artifacts);

  // ============================================================================
  // PHASE 6: DOCUMENTATION AND REPORTING
  // ============================================================================

  ctx.log('info', 'Phase 6: Documenting findings with reproduction steps');

  const documentation = await ctx.task(documentationTask, {
    projectName,
    vulnerabilities: vulnerabilityValidation.confirmedVulnerabilities,
    targetAnalysis,
    documentationLevel,
    outputDir
  });

  artifacts.push(...documentation.artifacts);

  await ctx.breakpoint({
    question: `Research complete for ${projectName}. ${vulnerabilityValidation.confirmedCount} confirmed vulnerabilities documented. Review final report?`,
    title: 'Final Research Review',
    context: {
      runId: ctx.runId,
      summary: {
        totalDiscovered: vulnerabilityDiscovery.vulnerabilities.length,
        confirmed: vulnerabilityValidation.confirmedCount,
        reportPath: documentation.reportPath
      },
      files: documentation.artifacts.map(a => ({ path: a.path, format: a.format || 'markdown', label: a.label }))
    }
  });

  const endTime = ctx.now();
  const duration = endTime - startTime;

  return {
    success: true,
    projectName,
    vulnerabilitiesFound: vulnerabilityValidation.confirmedVulnerabilities,
    researchReport: {
      reportPath: documentation.reportPath,
      totalDiscovered: vulnerabilityDiscovery.vulnerabilities.length,
      confirmed: vulnerabilityValidation.confirmedCount,
      bySeverity: vulnerabilityValidation.bySeverity
    },
    artifacts,
    duration,
    metadata: {
      processId: 'specializations/security-research/vulnerability-research-workflow',
      timestamp: startTime,
      testingMethodology,
      outputDir
    }
  };
}

// ============================================================================
// TASK DEFINITIONS
// ============================================================================

export const scopeDefinitionTask = defineTask('scope-definition', (args, taskCtx) => ({
  kind: 'agent',
  title: `Define Research Scope - ${args.projectName}`,
  agent: {
    name: 'security-researcher',
    prompt: {
      role: 'Security Research Coordinator',
      task: 'Define vulnerability research scope and verify authorization',
      context: args,
      instructions: [
        '1. Document all in-scope targets (applications, APIs, networks, code)',
        '2. Identify out-of-scope areas and boundaries',
        '3. Verify authorization type (bug bounty, engagement, internal)',
        '4. Document authorization evidence and constraints',
        '5. Define testing methodology (OWASP, PTES, custom)',
        '6. Establish responsible disclosure guidelines',
        '7. Create research timeline and milestones',
        '8. Document ethical and legal considerations'
      ],
      outputFormat: 'JSON with scope definition and authorization status'
    },
    outputSchema: {
      type: 'object',
      required: ['targetsInScope', 'authorizationVerified', 'artifacts'],
      properties: {
        targetsInScope: { type: 'number' },
        authorizationVerified: { type: 'boolean' },
        scopeDocument: { type: 'string' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'scope-definition']
}));

export const targetAnalysisTask = defineTask('target-analysis', (args, taskCtx) => ({
  kind: 'agent',
  title: `Analyze Target Architecture - ${args.projectName}`,
  agent: {
    name: 'security-researcher',
    prompt: {
      role: 'Security Research Analyst',
      task: 'Analyze target architecture and identify attack surface',
      context: args,
      instructions: [
        '1. Map target architecture and components',
        '2. Identify technologies and frameworks used',
        '3. Analyze authentication and authorization mechanisms',
        '4. Document data flows and trust boundaries',
        '5. Identify potential attack vectors',
        '6. Review public documentation and API specifications',
        '7. Assess security controls and mitigations',
        '8. Create attack surface map'
      ],
      outputFormat: 'JSON with target analysis and attack surface'
    },
    outputSchema: {
      type: 'object',
      required: ['attackSurface', 'technologies', 'artifacts'],
      properties: {
        attackSurface: { type: 'object' },
        technologies: { type: 'array', items: { type: 'string' } },
        components: { type: 'array' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'target-analysis']
}));

export const entryPointEnumerationTask = defineTask('entry-point-enumeration', (args, taskCtx) => ({
  kind: 'agent',
  title: `Enumerate Entry Points - ${args.projectName}`,
  agent: {
    name: 'security-researcher',
    prompt: {
      role: 'Security Research Analyst',
      task: 'Enumerate all entry points and data flows',
      context: args,
      instructions: [
        '1. Identify all input vectors (forms, APIs, files, headers)',
        '2. Map data flows from sources to sinks',
        '3. Document authentication entry points',
        '4. Identify privileged functionality',
        '5. Enumerate API endpoints and parameters',
        '6. Document file upload and processing points',
        '7. Identify inter-service communication',
        '8. Create comprehensive entry point catalog'
      ],
      outputFormat: 'JSON with entry points and data flows'
    },
    outputSchema: {
      type: 'object',
      required: ['entryPoints', 'dataFlows', 'artifacts'],
      properties: {
        entryPoints: { type: 'array' },
        dataFlows: { type: 'array' },
        totalEntryPoints: { type: 'number' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'enumeration']
}));

export const vulnerabilityDiscoveryTask = defineTask('vulnerability-discovery', (args, taskCtx) => ({
  kind: 'agent',
  title: `Discover Vulnerabilities - ${args.projectName}`,
  agent: {
    name: 'security-researcher',
    prompt: {
      role: 'Vulnerability Researcher',
      task: 'Apply systematic vulnerability discovery techniques',
      context: args,
      instructions: [
        '1. Test for injection vulnerabilities (SQL, XSS, command, LDAP)',
        '2. Test authentication and session management',
        '3. Test authorization and access control',
        '4. Test cryptographic implementations',
        '5. Test business logic flaws',
        '6. Test for information disclosure',
        '7. Test error handling and logging',
        '8. Document all potential findings with evidence'
      ],
      outputFormat: 'JSON with discovered vulnerabilities'
    },
    outputSchema: {
      type: 'object',
      required: ['vulnerabilities', 'bySeverity', 'artifacts'],
      properties: {
        vulnerabilities: { type: 'array' },
        bySeverity: { type: 'object' },
        totalFound: { type: 'number' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'vulnerability-discovery']
}));

export const vulnerabilityValidationTask = defineTask('vulnerability-validation', (args, taskCtx) => ({
  kind: 'agent',
  title: `Validate Vulnerabilities - ${args.projectName}`,
  agent: {
    name: 'security-researcher',
    prompt: {
      role: 'Vulnerability Validation Specialist',
      task: 'Validate and confirm discovered vulnerabilities',
      context: args,
      instructions: [
        '1. Verify each vulnerability can be reproduced',
        '2. Confirm exploitability and impact',
        '3. Assess CVSS score for each vulnerability',
        '4. Identify false positives',
        '5. Determine affected versions/configurations',
        '6. Document proof-of-concept for each finding',
        '7. Assess real-world exploitation likelihood',
        '8. Categorize by CWE classification'
      ],
      outputFormat: 'JSON with validated vulnerabilities'
    },
    outputSchema: {
      type: 'object',
      required: ['confirmedVulnerabilities', 'confirmedCount', 'artifacts'],
      properties: {
        confirmedVulnerabilities: { type: 'array' },
        confirmedCount: { type: 'number' },
        falsePositives: { type: 'number' },
        bySeverity: { type: 'object' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'validation']
}));

export const documentationTask = defineTask('documentation', (args, taskCtx) => ({
  kind: 'agent',
  title: `Document Findings - ${args.projectName}`,
  agent: {
    name: 'security-researcher',
    prompt: {
      role: 'Security Documentation Specialist',
      task: 'Create comprehensive vulnerability documentation',
      context: args,
      instructions: [
        '1. Create executive summary of findings',
        '2. Document each vulnerability with full details',
        '3. Include step-by-step reproduction instructions',
        '4. Provide proof-of-concept code/screenshots',
        '5. Document impact and risk assessment',
        '6. Provide remediation recommendations',
        '7. Include technical appendices',
        '8. Format as professional research report'
      ],
      outputFormat: 'JSON with documentation paths and summary'
    },
    outputSchema: {
      type: 'object',
      required: ['reportPath', 'artifacts'],
      properties: {
        reportPath: { type: 'string' },
        executiveSummary: { type: 'string' },
        vulnerabilityCount: { type: 'number' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'documentation']
}));
