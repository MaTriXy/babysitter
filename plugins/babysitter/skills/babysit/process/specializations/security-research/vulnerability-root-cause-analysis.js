/**
 * @process specializations/security-research/vulnerability-root-cause-analysis
 * @description Deep technical analysis to understand the root cause of discovered vulnerabilities,
 * determine exploitability, assess impact using CVSS, and identify related vulnerability patterns
 * for comprehensive security assessment.
 * @inputs { projectName: string, vulnerability: object, codebasePath?: string }
 * @outputs { success: boolean, rootCause: object, exploitability: object, cvssScore: number, relatedPatterns: array, artifacts: array }
 *
 * @example
 * const result = await orchestrate('specializations/security-research/vulnerability-root-cause-analysis', {
 *   projectName: 'Buffer Overflow Analysis',
 *   vulnerability: {
 *     type: 'buffer-overflow',
 *     location: 'parser.c:245',
 *     description: 'Stack buffer overflow in packet parser'
 *   },
 *   codebasePath: '/path/to/source'
 * });
 *
 * @references
 * - CWE: https://cwe.mitre.org/
 * - CVSS: https://www.first.org/cvss/
 */

import { defineTask } from '@a5c-ai/babysitter-sdk';

export async function process(inputs, ctx) {
  const {
    projectName,
    vulnerability,
    codebasePath = null,
    analyzeVariants = true,
    outputDir = 'root-cause-analysis-output'
  } = inputs;

  const startTime = ctx.now();
  const artifacts = [];

  ctx.log('info', `Starting Root Cause Analysis for ${projectName}`);
  ctx.log('info', `Vulnerability: ${vulnerability.type} at ${vulnerability.location}`);

  // ============================================================================
  // PHASE 1: TRIGGER CONDITION ANALYSIS
  // ============================================================================

  ctx.log('info', 'Phase 1: Analyzing vulnerability trigger conditions');

  const triggerAnalysis = await ctx.task(triggerAnalysisTask, {
    projectName,
    vulnerability,
    codebasePath,
    outputDir
  });

  artifacts.push(...triggerAnalysis.artifacts);

  // ============================================================================
  // PHASE 2: ROOT CAUSE IDENTIFICATION
  // ============================================================================

  ctx.log('info', 'Phase 2: Tracing to root cause in code');

  const rootCauseIdentification = await ctx.task(rootCauseIdentificationTask, {
    projectName,
    vulnerability,
    triggerAnalysis,
    codebasePath,
    outputDir
  });

  artifacts.push(...rootCauseIdentification.artifacts);

  // ============================================================================
  // PHASE 3: AFFECTED VERSIONS ANALYSIS
  // ============================================================================

  ctx.log('info', 'Phase 3: Determining affected versions and configurations');

  const versionAnalysis = await ctx.task(versionAnalysisTask, {
    projectName,
    vulnerability,
    rootCauseIdentification,
    outputDir
  });

  artifacts.push(...versionAnalysis.artifacts);

  // ============================================================================
  // PHASE 4: EXPLOITABILITY ASSESSMENT
  // ============================================================================

  ctx.log('info', 'Phase 4: Assessing exploitability and constraints');

  const exploitabilityAssessment = await ctx.task(exploitabilityAssessmentTask, {
    projectName,
    vulnerability,
    rootCauseIdentification,
    triggerAnalysis,
    outputDir
  });

  artifacts.push(...exploitabilityAssessment.artifacts);

  // ============================================================================
  // PHASE 5: CVSS SCORING
  // ============================================================================

  ctx.log('info', 'Phase 5: Calculating severity using CVSS');

  const cvssScoring = await ctx.task(cvssScoringTask, {
    projectName,
    vulnerability,
    exploitabilityAssessment,
    versionAnalysis,
    outputDir
  });

  artifacts.push(...cvssScoring.artifacts);

  // ============================================================================
  // PHASE 6: PATTERN IDENTIFICATION
  // ============================================================================

  ctx.log('info', 'Phase 6: Identifying related vulnerability patterns');

  const patternIdentification = await ctx.task(patternIdentificationTask, {
    projectName,
    vulnerability,
    rootCauseIdentification,
    codebasePath,
    outputDir
  });

  artifacts.push(...patternIdentification.artifacts);

  // ============================================================================
  // PHASE 7: REMEDIATION RECOMMENDATIONS
  // ============================================================================

  ctx.log('info', 'Phase 7: Documenting remediation recommendations');

  const remediationRecommendations = await ctx.task(remediationRecommendationsTask, {
    projectName,
    vulnerability,
    rootCauseIdentification,
    patternIdentification,
    outputDir
  });

  artifacts.push(...remediationRecommendations.artifacts);

  await ctx.breakpoint({
    question: `Root cause analysis complete. CVSS: ${cvssScoring.cvssScore}. ${patternIdentification.relatedPatterns.length} related patterns found. Review analysis?`,
    title: 'Root Cause Analysis Complete',
    context: {
      runId: ctx.runId,
      summary: {
        rootCause: rootCauseIdentification.rootCause,
        cvssScore: cvssScoring.cvssScore,
        exploitable: exploitabilityAssessment.exploitable,
        relatedPatterns: patternIdentification.relatedPatterns.length
      },
      files: artifacts.map(a => ({ path: a.path, format: a.format || 'json', label: a.label }))
    }
  });

  const endTime = ctx.now();

  return {
    success: true,
    projectName,
    rootCause: {
      description: rootCauseIdentification.rootCause,
      cweId: rootCauseIdentification.cweId,
      location: rootCauseIdentification.location,
      triggerConditions: triggerAnalysis.conditions
    },
    exploitability: {
      exploitable: exploitabilityAssessment.exploitable,
      complexity: exploitabilityAssessment.complexity,
      constraints: exploitabilityAssessment.constraints,
      prerequisites: exploitabilityAssessment.prerequisites
    },
    cvssScore: cvssScoring.cvssScore,
    cvssVector: cvssScoring.cvssVector,
    relatedPatterns: patternIdentification.relatedPatterns,
    affectedVersions: versionAnalysis.affectedVersions,
    remediation: remediationRecommendations.recommendations,
    artifacts,
    duration: endTime - startTime,
    metadata: {
      processId: 'specializations/security-research/vulnerability-root-cause-analysis',
      timestamp: startTime,
      outputDir
    }
  };
}

// ============================================================================
// TASK DEFINITIONS
// ============================================================================

export const triggerAnalysisTask = defineTask('trigger-analysis', (args, taskCtx) => ({
  kind: 'agent',
  title: `Analyze Trigger Conditions - ${args.projectName}`,
  agent: {
    name: 'vuln-researcher',
    prompt: {
      role: 'Vulnerability Trigger Analyst',
      task: 'Analyze conditions that trigger the vulnerability',
      context: args,
      instructions: [
        '1. Identify input that triggers vulnerability',
        '2. Document minimum trigger conditions',
        '3. Analyze input constraints',
        '4. Identify state requirements',
        '5. Document environmental factors',
        '6. Test edge case triggers',
        '7. Map trigger path through code',
        '8. Create minimal reproduction steps'
      ],
      outputFormat: 'JSON with trigger analysis'
    },
    outputSchema: {
      type: 'object',
      required: ['conditions', 'triggerInput', 'artifacts'],
      properties: {
        conditions: { type: 'array' },
        triggerInput: { type: 'object' },
        stateRequirements: { type: 'array' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'root-cause', 'trigger']
}));

export const rootCauseIdentificationTask = defineTask('root-cause-identification', (args, taskCtx) => ({
  kind: 'agent',
  title: `Identify Root Cause - ${args.projectName}`,
  agent: {
    name: 'vuln-researcher',
    prompt: {
      role: 'Root Cause Analysis Specialist',
      task: 'Trace vulnerability to its root cause in code',
      context: args,
      instructions: [
        '1. Trace execution path to vulnerability',
        '2. Identify the root cause in code',
        '3. Determine CWE classification',
        '4. Document the vulnerable code pattern',
        '5. Identify contributing factors',
        '6. Analyze code context',
        '7. Document the failure mode',
        '8. Identify when bug was introduced'
      ],
      outputFormat: 'JSON with root cause details'
    },
    outputSchema: {
      type: 'object',
      required: ['rootCause', 'cweId', 'location', 'artifacts'],
      properties: {
        rootCause: { type: 'string' },
        cweId: { type: 'string' },
        location: { type: 'object' },
        vulnerablePattern: { type: 'string' },
        contributingFactors: { type: 'array' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'root-cause', 'identification']
}));

export const versionAnalysisTask = defineTask('version-analysis', (args, taskCtx) => ({
  kind: 'agent',
  title: `Analyze Affected Versions - ${args.projectName}`,
  agent: {
    name: 'vuln-researcher',
    prompt: {
      role: 'Version Impact Analyst',
      task: 'Determine affected versions and configurations',
      context: args,
      instructions: [
        '1. Identify all affected versions',
        '2. Determine first vulnerable version',
        '3. Check if fixed in any version',
        '4. Identify vulnerable configurations',
        '5. Document platform dependencies',
        '6. Check for backports of vulnerability',
        '7. Assess deployment exposure',
        '8. Create version impact matrix'
      ],
      outputFormat: 'JSON with version analysis'
    },
    outputSchema: {
      type: 'object',
      required: ['affectedVersions', 'firstVulnerable', 'artifacts'],
      properties: {
        affectedVersions: { type: 'array' },
        firstVulnerable: { type: 'string' },
        fixedVersions: { type: 'array' },
        vulnerableConfigs: { type: 'array' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'root-cause', 'versions']
}));

export const exploitabilityAssessmentTask = defineTask('exploitability-assessment', (args, taskCtx) => ({
  kind: 'agent',
  title: `Assess Exploitability - ${args.projectName}`,
  agent: {
    name: 'exploit-developer',
    prompt: {
      role: 'Exploitability Assessment Specialist',
      task: 'Assess vulnerability exploitability and constraints',
      context: args,
      instructions: [
        '1. Determine if vulnerability is exploitable',
        '2. Assess exploitation complexity',
        '3. Identify exploitation prerequisites',
        '4. Document mitigating factors',
        '5. Assess privilege requirements',
        '6. Evaluate user interaction needs',
        '7. Check for existing mitigations (ASLR, DEP)',
        '8. Document exploitation constraints'
      ],
      outputFormat: 'JSON with exploitability assessment'
    },
    outputSchema: {
      type: 'object',
      required: ['exploitable', 'complexity', 'constraints', 'artifacts'],
      properties: {
        exploitable: { type: 'boolean' },
        complexity: { type: 'string', enum: ['low', 'medium', 'high'] },
        constraints: { type: 'array' },
        prerequisites: { type: 'array' },
        mitigations: { type: 'array' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'root-cause', 'exploitability']
}));

export const cvssScoringTask = defineTask('cvss-scoring', (args, taskCtx) => ({
  kind: 'agent',
  title: `Calculate CVSS Score - ${args.projectName}`,
  agent: {
    name: 'vuln-researcher',
    prompt: {
      role: 'CVSS Scoring Specialist',
      task: 'Calculate severity using CVSS v3.1',
      context: args,
      instructions: [
        '1. Assess Attack Vector (Network, Adjacent, Local, Physical)',
        '2. Assess Attack Complexity (Low, High)',
        '3. Assess Privileges Required (None, Low, High)',
        '4. Assess User Interaction (None, Required)',
        '5. Assess Scope (Unchanged, Changed)',
        '6. Assess Confidentiality Impact (None, Low, High)',
        '7. Assess Integrity Impact (None, Low, High)',
        '8. Assess Availability Impact (None, Low, High)',
        '9. Calculate Base Score',
        '10. Generate CVSS Vector String'
      ],
      outputFormat: 'JSON with CVSS scoring'
    },
    outputSchema: {
      type: 'object',
      required: ['cvssScore', 'cvssVector', 'severity', 'artifacts'],
      properties: {
        cvssScore: { type: 'number' },
        cvssVector: { type: 'string' },
        severity: { type: 'string', enum: ['critical', 'high', 'medium', 'low', 'none'] },
        metrics: { type: 'object' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'root-cause', 'cvss']
}));

export const patternIdentificationTask = defineTask('pattern-identification', (args, taskCtx) => ({
  kind: 'agent',
  title: `Identify Related Patterns - ${args.projectName}`,
  agent: {
    name: 'vuln-researcher',
    prompt: {
      role: 'Vulnerability Pattern Analyst',
      task: 'Identify related vulnerability patterns in codebase',
      context: args,
      instructions: [
        '1. Define vulnerability pattern signature',
        '2. Search for similar patterns',
        '3. Identify incomplete fixes',
        '4. Check for variant vulnerabilities',
        '5. Analyze related CWE patterns',
        '6. Document pattern characteristics',
        '7. Assess systemic issues',
        '8. Create pattern detection rules'
      ],
      outputFormat: 'JSON with related patterns'
    },
    outputSchema: {
      type: 'object',
      required: ['relatedPatterns', 'patternSignature', 'artifacts'],
      properties: {
        relatedPatterns: { type: 'array' },
        patternSignature: { type: 'string' },
        variantsFound: { type: 'number' },
        incompleteFixes: { type: 'array' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'root-cause', 'patterns']
}));

export const remediationRecommendationsTask = defineTask('remediation-recommendations', (args, taskCtx) => ({
  kind: 'agent',
  title: `Document Remediation - ${args.projectName}`,
  agent: {
    name: 'security-report-writer',
    prompt: {
      role: 'Security Remediation Advisor',
      task: 'Document remediation recommendations',
      context: args,
      instructions: [
        '1. Provide specific code fix recommendations',
        '2. Suggest secure coding patterns',
        '3. Document workarounds if needed',
        '4. Recommend defensive measures',
        '5. Suggest testing approaches',
        '6. Address related patterns',
        '7. Provide long-term improvements',
        '8. Create prioritized fix list'
      ],
      outputFormat: 'JSON with remediation recommendations'
    },
    outputSchema: {
      type: 'object',
      required: ['recommendations', 'codeFix', 'artifacts'],
      properties: {
        recommendations: { type: 'array' },
        codeFix: { type: 'string' },
        workarounds: { type: 'array' },
        defensiveMeasures: { type: 'array' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'root-cause', 'remediation']
}));
