/**
 * @process specializations/security-research/malware-analysis
 * @description Systematic analysis of malicious software to understand capabilities, behavior, indicators
 * of compromise, and attribution. Includes both static and dynamic analysis techniques using REMnux,
 * Cuckoo Sandbox, and YARA.
 * @inputs { projectName: string, samplePath: string, analysisType?: string }
 * @outputs { success: boolean, analysisReport: object, iocs: array, yaraRules: array, artifacts: array }
 *
 * @example
 * const result = await orchestrate('specializations/security-research/malware-analysis', {
 *   projectName: 'Ransomware Sample Analysis',
 *   samplePath: '/path/to/sample',
 *   analysisType: 'comprehensive'
 * });
 *
 * @references
 * - REMnux: https://remnux.org/
 * - Cuckoo Sandbox: https://cuckoosandbox.org/
 * - YARA: https://virustotal.github.io/yara/
 */

import { defineTask } from '@a5c-ai/babysitter-sdk';

export async function process(inputs, ctx) {
  const {
    projectName,
    samplePath,
    analysisType = 'comprehensive',
    sandbox = 'cuckoo',
    outputDir = 'malware-analysis-output'
  } = inputs;

  const startTime = ctx.now();
  const artifacts = [];
  const iocs = [];

  ctx.log('info', `Starting Malware Analysis for ${projectName}`);
  ctx.log('info', `Sample: ${samplePath}, Analysis Type: ${analysisType}`);

  // ============================================================================
  // PHASE 1: ENVIRONMENT SETUP
  // ============================================================================

  ctx.log('info', 'Phase 1: Setting up isolated analysis environment');

  const envSetup = await ctx.task(analysisEnvSetupTask, {
    projectName,
    samplePath,
    sandbox,
    outputDir
  });

  artifacts.push(...envSetup.artifacts);

  // ============================================================================
  // PHASE 2: STATIC ANALYSIS
  // ============================================================================

  ctx.log('info', 'Phase 2: Performing static analysis');

  const staticAnalysis = await ctx.task(malwareStaticAnalysisTask, {
    projectName,
    samplePath,
    outputDir
  });

  iocs.push(...staticAnalysis.iocs);
  artifacts.push(...staticAnalysis.artifacts);

  // ============================================================================
  // PHASE 3: BEHAVIORAL ANALYSIS
  // ============================================================================

  ctx.log('info', 'Phase 3: Executing in sandbox for behavioral analysis');

  const behavioralAnalysis = await ctx.task(behavioralAnalysisTask, {
    projectName,
    samplePath,
    envSetup,
    sandbox,
    outputDir
  });

  iocs.push(...behavioralAnalysis.iocs);
  artifacts.push(...behavioralAnalysis.artifacts);

  // ============================================================================
  // PHASE 4: NETWORK ANALYSIS
  // ============================================================================

  ctx.log('info', 'Phase 4: Analyzing network communications');

  const networkAnalysis = await ctx.task(malwareNetworkAnalysisTask, {
    projectName,
    behavioralAnalysis,
    outputDir
  });

  iocs.push(...networkAnalysis.iocs);
  artifacts.push(...networkAnalysis.artifacts);

  // ============================================================================
  // PHASE 5: PERSISTENCE ANALYSIS
  // ============================================================================

  ctx.log('info', 'Phase 5: Identifying persistence mechanisms');

  const persistenceAnalysis = await ctx.task(persistenceAnalysisTask, {
    projectName,
    behavioralAnalysis,
    outputDir
  });

  artifacts.push(...persistenceAnalysis.artifacts);

  // ============================================================================
  // PHASE 6: IOC EXTRACTION
  // ============================================================================

  ctx.log('info', 'Phase 6: Extracting indicators of compromise');

  const iocExtraction = await ctx.task(iocExtractionTask, {
    projectName,
    staticAnalysis,
    behavioralAnalysis,
    networkAnalysis,
    outputDir
  });

  artifacts.push(...iocExtraction.artifacts);

  // ============================================================================
  // PHASE 7: YARA RULE CREATION
  // ============================================================================

  ctx.log('info', 'Phase 7: Creating YARA detection rules');

  const yaraCreation = await ctx.task(yaraRuleCreationTask, {
    projectName,
    staticAnalysis,
    iocs: iocExtraction.consolidatedIocs,
    outputDir
  });

  artifacts.push(...yaraCreation.artifacts);

  // ============================================================================
  // PHASE 8: DOCUMENTATION
  // ============================================================================

  ctx.log('info', 'Phase 8: Documenting analysis findings');

  const documentation = await ctx.task(malwareDocumentationTask, {
    projectName,
    staticAnalysis,
    behavioralAnalysis,
    networkAnalysis,
    persistenceAnalysis,
    iocExtraction,
    yaraCreation,
    outputDir
  });

  artifacts.push(...documentation.artifacts);

  await ctx.breakpoint({
    question: `Malware analysis complete for ${projectName}. ${iocExtraction.consolidatedIocs.length} IOCs extracted, ${yaraCreation.rulesCreated} YARA rules created. Review findings?`,
    title: 'Malware Analysis Complete',
    context: {
      runId: ctx.runId,
      summary: {
        malwareType: staticAnalysis.malwareType,
        capabilities: behavioralAnalysis.capabilities,
        iocs: iocExtraction.consolidatedIocs.length,
        yaraRules: yaraCreation.rulesCreated
      },
      files: documentation.artifacts.map(a => ({ path: a.path, format: a.format || 'markdown', label: a.label }))
    }
  });

  const endTime = ctx.now();

  return {
    success: true,
    projectName,
    analysisReport: {
      malwareType: staticAnalysis.malwareType,
      capabilities: behavioralAnalysis.capabilities,
      reportPath: documentation.reportPath
    },
    iocs: iocExtraction.consolidatedIocs,
    yaraRules: yaraCreation.rules,
    artifacts,
    duration: endTime - startTime,
    metadata: {
      processId: 'specializations/security-research/malware-analysis',
      timestamp: startTime,
      analysisType,
      outputDir
    }
  };
}

// ============================================================================
// TASK DEFINITIONS
// ============================================================================

export const analysisEnvSetupTask = defineTask('analysis-env-setup', (args, taskCtx) => ({
  kind: 'agent',
  title: `Setup Analysis Environment - ${args.projectName}`,
  agent: {
    name: 'malware-analyst',
    prompt: {
      role: 'Malware Analysis Environment Specialist',
      task: 'Set up isolated analysis environment',
      context: args,
      instructions: [
        '1. Verify isolation from production',
        '2. Set up analysis VM',
        '3. Configure network isolation',
        '4. Install analysis tools',
        '5. Configure sandbox',
        '6. Set up monitoring',
        '7. Create snapshots',
        '8. Document environment'
      ],
      outputFormat: 'JSON with environment setup'
    },
    outputSchema: {
      type: 'object',
      required: ['environmentReady', 'isolated', 'artifacts'],
      properties: {
        environmentReady: { type: 'boolean' },
        isolated: { type: 'boolean' },
        sandboxId: { type: 'string' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'malware', 'environment']
}));

export const malwareStaticAnalysisTask = defineTask('malware-static-analysis', (args, taskCtx) => ({
  kind: 'agent',
  title: `Static Analysis - ${args.projectName}`,
  agent: {
    name: 'malware-analyst',
    prompt: {
      role: 'Malware Static Analyst',
      task: 'Perform static analysis of malware sample',
      context: args,
      instructions: [
        '1. Calculate file hashes',
        '2. Analyze file headers',
        '3. Extract strings',
        '4. Analyze imports/exports',
        '5. Check for packing',
        '6. Identify malware type',
        '7. Extract embedded data',
        '8. Document static findings'
      ],
      outputFormat: 'JSON with static analysis'
    },
    outputSchema: {
      type: 'object',
      required: ['malwareType', 'hashes', 'iocs', 'artifacts'],
      properties: {
        malwareType: { type: 'string' },
        hashes: { type: 'object' },
        strings: { type: 'array' },
        imports: { type: 'array' },
        packed: { type: 'boolean' },
        iocs: { type: 'array' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'malware', 'static']
}));

export const behavioralAnalysisTask = defineTask('behavioral-analysis', (args, taskCtx) => ({
  kind: 'agent',
  title: `Behavioral Analysis - ${args.projectName}`,
  agent: {
    name: 'malware-analyst',
    prompt: {
      role: 'Malware Behavioral Analyst',
      task: 'Execute in sandbox for behavioral analysis',
      context: args,
      instructions: [
        '1. Execute sample in sandbox',
        '2. Monitor file operations',
        '3. Monitor registry changes',
        '4. Monitor process creation',
        '5. Monitor API calls',
        '6. Identify capabilities',
        '7. Record behavior timeline',
        '8. Document behavioral findings'
      ],
      outputFormat: 'JSON with behavioral analysis'
    },
    outputSchema: {
      type: 'object',
      required: ['capabilities', 'behaviors', 'iocs', 'artifacts'],
      properties: {
        capabilities: { type: 'array' },
        behaviors: { type: 'array' },
        fileOperations: { type: 'array' },
        registryChanges: { type: 'array' },
        processCreation: { type: 'array' },
        iocs: { type: 'array' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'malware', 'behavioral']
}));

export const malwareNetworkAnalysisTask = defineTask('malware-network-analysis', (args, taskCtx) => ({
  kind: 'agent',
  title: `Network Analysis - ${args.projectName}`,
  agent: {
    name: 'malware-analyst',
    prompt: {
      role: 'Malware Network Analyst',
      task: 'Analyze network communications',
      context: args,
      instructions: [
        '1. Capture network traffic',
        '2. Identify C2 communications',
        '3. Extract domains/IPs',
        '4. Analyze protocols used',
        '5. Identify data exfiltration',
        '6. Decrypt traffic if possible',
        '7. Document network IOCs',
        '8. Create network diagram'
      ],
      outputFormat: 'JSON with network analysis'
    },
    outputSchema: {
      type: 'object',
      required: ['c2Servers', 'domains', 'iocs', 'artifacts'],
      properties: {
        c2Servers: { type: 'array' },
        domains: { type: 'array' },
        ips: { type: 'array' },
        protocols: { type: 'array' },
        iocs: { type: 'array' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'malware', 'network']
}));

export const persistenceAnalysisTask = defineTask('persistence-analysis', (args, taskCtx) => ({
  kind: 'agent',
  title: `Persistence Analysis - ${args.projectName}`,
  agent: {
    name: 'malware-analyst',
    prompt: {
      role: 'Persistence Mechanism Analyst',
      task: 'Identify persistence mechanisms',
      context: args,
      instructions: [
        '1. Check autorun locations',
        '2. Check scheduled tasks',
        '3. Check services',
        '4. Check registry keys',
        '5. Check WMI subscriptions',
        '6. Check startup folders',
        '7. Identify rootkit techniques',
        '8. Document persistence methods'
      ],
      outputFormat: 'JSON with persistence analysis'
    },
    outputSchema: {
      type: 'object',
      required: ['mechanisms', 'artifacts'],
      properties: {
        mechanisms: { type: 'array' },
        autoruns: { type: 'array' },
        services: { type: 'array' },
        scheduledTasks: { type: 'array' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'malware', 'persistence']
}));

export const iocExtractionTask = defineTask('ioc-extraction', (args, taskCtx) => ({
  kind: 'agent',
  title: `Extract IOCs - ${args.projectName}`,
  agent: {
    name: 'malware-analyst',
    prompt: {
      role: 'IOC Extraction Specialist',
      task: 'Extract indicators of compromise',
      context: args,
      instructions: [
        '1. Consolidate all IOCs',
        '2. Categorize IOCs by type',
        '3. Validate IOC accuracy',
        '4. Remove false positives',
        '5. Format in STIX/OpenIOC',
        '6. Create IOC feed',
        '7. Prioritize for detection',
        '8. Document IOC list'
      ],
      outputFormat: 'JSON with IOCs'
    },
    outputSchema: {
      type: 'object',
      required: ['consolidatedIocs', 'artifacts'],
      properties: {
        consolidatedIocs: { type: 'array' },
        byType: { type: 'object' },
        stixBundle: { type: 'object' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'malware', 'iocs']
}));

export const yaraRuleCreationTask = defineTask('yara-rule-creation', (args, taskCtx) => ({
  kind: 'agent',
  title: `Create YARA Rules - ${args.projectName}`,
  agent: {
    name: 'malware-analyst',
    prompt: {
      role: 'YARA Rule Developer',
      task: 'Create YARA detection rules',
      context: args,
      instructions: [
        '1. Identify unique patterns',
        '2. Create string-based rules',
        '3. Create byte-pattern rules',
        '4. Add condition logic',
        '5. Test for false positives',
        '6. Optimize rule performance',
        '7. Add metadata',
        '8. Document rules'
      ],
      outputFormat: 'JSON with YARA rules'
    },
    outputSchema: {
      type: 'object',
      required: ['rules', 'rulesCreated', 'artifacts'],
      properties: {
        rules: { type: 'array' },
        rulesCreated: { type: 'number' },
        rulesPath: { type: 'string' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'malware', 'yara']
}));

export const malwareDocumentationTask = defineTask('malware-documentation', (args, taskCtx) => ({
  kind: 'agent',
  title: `Document Analysis - ${args.projectName}`,
  agent: {
    name: 'security-report-writer',
    prompt: {
      role: 'Malware Documentation Specialist',
      task: 'Document analysis findings',
      context: args,
      instructions: [
        '1. Create executive summary',
        '2. Document malware overview',
        '3. Document capabilities',
        '4. Include IOC list',
        '5. Include YARA rules',
        '6. Document mitigation',
        '7. Add technical appendix',
        '8. Format as professional report'
      ],
      outputFormat: 'JSON with documentation'
    },
    outputSchema: {
      type: 'object',
      required: ['reportPath', 'summary', 'artifacts'],
      properties: {
        reportPath: { type: 'string' },
        summary: { type: 'object' },
        artifacts: { type: 'array' }
      }
    }
  },
  io: {
    inputJsonPath: `tasks/${taskCtx.effectId}/input.json`,
    outputJsonPath: `tasks/${taskCtx.effectId}/result.json`
  },
  labels: ['agent', 'security-research', 'malware', 'documentation']
}));
